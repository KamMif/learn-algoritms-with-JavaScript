// Чтобы разобраться что такое стек вызовов - разберем как работает функция
// Предположим что в программе используется вызов greet('maggie')
// Сначала ваш компьютер выделяет блок памяти для вызова функции
// Затем эта память используется. Переменной name присваивается значение 'maggie'
// Оно должно быть сохранено в памяти
// Каждый раз при вызове функции, компьютер сохраняет в памяти все значения переменных для это вызова
// Далее выводится преветствие 'hello maggie!'
// После чего следует второй вызов great2('maggie') и снова компьютер выделяет блок памяти для вызова функции
// Компьютер обьединяет эти блоки в стек - Второй блок создается над первым
// Вы выводите сообщение 'how are you, maggie?' после чего возвращаете управление из вызова функции
// Когда это происходит, блок на вершине стека извлекается из него
// Теперь верхний блок в стеке относится к функции greet; это означает что вы вернулись к функции greet
// При вызове greet2 функция greet не была завершена
// КОГДА ВЫ ВЫЗЫВАЕТЕ ФУНКЦИЮ ИЗ ДРУГОЙ ФУНКЦИИ, ВЫЗЫВАЮЩАЯ ФУНКЦИЯ ПРИОСТАНАВЛИВАЕТСЯ В ЧАСТИЧНО ЗАВЕРШЕННОМ СОСТОЯНИИ
// Все значения переменных этой функции остаются в памяти
// Когда выполнение функции greet2 будет завершено, вы вернетесь к функции greet и продолжите ее
// выполнение с того места где оно прервалось
// Сначала выводится сообщение 'greeting ready to say bye...' после чего функция bye()
//Блок для этой функции добавляется на вершину стека, далее выводится сообщение 'ok bye' с выходом из вызова функции
// Управление снова возвращается функции greet()
// Этот стек в котором сохранялись переменные разных функций - называется стеком вызовов


function greet(name) {
    console.log('hello, ' + name = '!')
    greet2(name)
    console.log('greeting ready to say bye...')
    bye()
}

function greet2(name) {
    console.log('how are you ' + name )
}

function bye() {
    console.log('ok bye!!!')
}



function fact(x) {
    if(x == 1) {
        return 1
    } else {
        return x * fact(x - 1)
    }
}




